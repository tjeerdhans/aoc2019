import Data.Char (digitToInt)

ops5 :: [Int]
ops5 = [3,225,1,225,6,6,1100,1,238,225,104,0,2,106,196,224,101,-1157,224,224,4,224,102,8,223,223,1001,224,7,224,1,224,223,223,1002,144,30,224,1001,224,-1710,224,4,224,1002,223,8,223,101,1,224,224,1,224,223,223,101,82,109,224,1001,224,-111,224,4,224,102,8,223,223,1001,224,4,224,1,223,224,223,1102,10,50,225,1102,48,24,224,1001,224,-1152,224,4,224,1002,223,8,223,101,5,224,224,1,223,224,223,1102,44,89,225,1101,29,74,225,1101,13,59,225,1101,49,60,225,1101,89,71,224,1001,224,-160,224,4,224,1002,223,8,223,1001,224,6,224,1,223,224,223,1101,27,57,225,102,23,114,224,1001,224,-1357,224,4,224,102,8,223,223,101,5,224,224,1,224,223,223,1001,192,49,224,1001,224,-121,224,4,224,1002,223,8,223,101,3,224,224,1,223,224,223,1102,81,72,225,1102,12,13,225,1,80,118,224,1001,224,-110,224,4,224,102,8,223,223,101,2,224,224,1,224,223,223,4,223,99,0,0,0,677,0,0,0,0,0,0,0,0,0,0,0,1105,0,99999,1105,227,247,1105,1,99999,1005,227,99999,1005,0,256,1105,1,99999,1106,227,99999,1106,0,265,1105,1,99999,1006,0,99999,1006,227,274,1105,1,99999,1105,1,280,1105,1,99999,1,225,225,225,1101,294,0,0,105,1,0,1105,1,99999,1106,0,300,1105,1,99999,1,225,225,225,1101,314,0,0,106,0,0,1105,1,99999,7,677,226,224,102,2,223,223,1005,224,329,101,1,223,223,108,226,226,224,102,2,223,223,1006,224,344,101,1,223,223,1108,226,677,224,102,2,223,223,1006,224,359,1001,223,1,223,107,677,677,224,1002,223,2,223,1005,224,374,1001,223,1,223,1107,226,677,224,102,2,223,223,1005,224,389,1001,223,1,223,107,677,226,224,1002,223,2,223,1005,224,404,101,1,223,223,8,226,677,224,102,2,223,223,1005,224,419,101,1,223,223,7,226,677,224,1002,223,2,223,1005,224,434,101,1,223,223,1007,677,677,224,102,2,223,223,1006,224,449,1001,223,1,223,107,226,226,224,1002,223,2,223,1006,224,464,1001,223,1,223,1007,226,226,224,102,2,223,223,1006,224,479,1001,223,1,223,1008,226,226,224,102,2,223,223,1006,224,494,101,1,223,223,7,677,677,224,102,2,223,223,1005,224,509,1001,223,1,223,108,677,226,224,102,2,223,223,1005,224,524,101,1,223,223,1108,677,226,224,1002,223,2,223,1006,224,539,101,1,223,223,1108,677,677,224,102,2,223,223,1005,224,554,101,1,223,223,8,677,226,224,102,2,223,223,1005,224,569,101,1,223,223,8,677,677,224,102,2,223,223,1005,224,584,101,1,223,223,1107,226,226,224,102,2,223,223,1006,224,599,101,1,223,223,108,677,677,224,102,2,223,223,1006,224,614,101,1,223,223,1008,677,226,224,1002,223,2,223,1005,224,629,1001,223,1,223,1107,677,226,224,102,2,223,223,1005,224,644,101,1,223,223,1008,677,677,224,1002,223,2,223,1005,224,659,101,1,223,223,1007,677,226,224,1002,223,2,223,1005,224,674,1001,223,1,223,4,223,99,226]
digits :: Int -> [Int]
digits = map digitToInt . show

fromDigits :: [Int] -> Int
fromDigits = foldl addDigit 0
   where addDigit num d = 10*num + d

decode op
    | op > 4 = fromDigits $ reverse $ take 2 $ reverse $ digits op -- read (reverse $ take 2 $ reverse $ show op) :: Integer
    | otherwise = op
modes op
    | op > 4 = drop 2 $ reverse $ digits op
    | otherwise = []

--cal :: [Integer] -> Integer -> [Integer] -> Integer -> (Integer, Integer)
cal xs op m i
    | op==1 = ( xs!!(i+3), 
        (if (length m > 0) && m!!0 == 1 
            then xs!!(i+1) 
            else xs!!(xs!!(i+1))) + 
        (if (length m > 1) && m!!1 == 1
            then xs!!(i+2) 
            else xs!!(xs!!(i+2)) ) ) 
    | op==2 = ( xs!!(i+3), 
        (if (length m > 0) && m!!0 == 1 
            then xs!!(i+1) 
            else xs!!(xs!!(i+1))) * 
        (if (length m > 1) && m!!1 == 1 
            then xs!!(i+2) 
            else xs!!(xs!!(i+2)) ) )
    | op==3 = ( xs!!(i+1), 1) -- input always 1
    | op==4 = ( -1, if (length m > 0) && m!!0 == 1 then xs!!(i+1) else xs!!(xs!!(i+1)))
    | otherwise = (-1,-1)

pv2 :: [Int] -> Int -> (Int, (Int, Int))
pv2 xs i
    | decode (xs!!i) <= 4 = (decode (xs!!i), cal xs (decode (xs!!i)) (modes (xs!!i)) i) -- ( operation, (target position, target value) )
    | otherwise = (99,(-1,-1))

--calc2 :: [Integer] -> Integer -> [Integer]
calc2 xs i
    | (pv2 xs i) == (99,(-1,-1)) = xs
    | otherwise = calc2 ([if (fst c) <= 3 && (fst (snd c) == index) then (snd (snd c)) else xs!!index | index <- [0..length xs-1], 
            let c = pv2 xs i]) (i+(if (fst (pv2 xs i)) <= 2 then 4 else 2))

result5a = calc2 ops5 0

fstcalc xs i = [if (fst c) <= 3 && (fst (snd c) == index) then (snd (snd c)) else xs!!index | index <- [0..length xs-1], let c = pv2 xs i]

getOutputs :: [Int] -> [Int] -> [Int]
getOutputs (x:xs) ys
    | decode x <= 2 = [] ++ getOutputs (drop 3 xs) ys
    | decode x == 3 = [] ++ getOutputs (drop 1 xs) ys
    | decode x == 4 = (if modes x == [] then [ys!!(head xs)] else [head xs]) ++ getOutputs (drop 1 xs) ys
    | otherwise = []

outputs = getOutputs result5a result5a